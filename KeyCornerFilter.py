import pandas as pd
import numpy as np
import fastf1
import fastf1.plotting
import matplotlib as mpl
import datetime
import timedelta

from scipy import stats
from scipy.signal import find_peaks
from sklearn.preprocessing import normalize
from matplotlib import pyplot as plt
from matplotlib.collections import LineCollection

def calculate_driver_confidence(lap, lap_list):
    '''PURPOSE OF THIS FUNCTION: 
    Use telemetry data and data that's been feature engineered to quantify a driver's confidence
    based on braking performance around corners. 
    TODO: 
    1. Normalize final varibles in equation 
    2. filter out braking zones that aren't important to analysis
    '''
    # Define final variable
    lap_cols = lap.telemetry.columns
    total_tel = pd.DataFrame(columns=lap_cols)
    for lap_number in lap_list:
        lap_tel = lap[lap['LapNumber'] == lap_number].telemetry
        lap_tel['LapNumber'] = lap_number
        # Start with distance traveled while braking
        # Group each braking zone
        # TODO: Refine the generation of brakezones, have it be correlated to each corner
        # Rather than being generated by braking events, making analysis easier and grouping 
        # more accurate to assumptions. 
        lap_tel['BrakeZone'] = lap_tel[lap_tel['Brake']].index.to_series().diff().ne(1).cumsum()

        # Calculate the total distance braked
        lap_tel['DistanceBraked'] = lap_tel.groupby('BrakeZone')['Distance'].diff().fillna(0)
        lap_tel['TotalDistanceBraked'] = lap_tel.groupby('BrakeZone')['DistanceBraked'].transform('sum')

        # Now Calculate Average Speed at braking
        lap_tel['AvgSpeedBraking'] = lap_tel.groupby('BrakeZone')['Speed'].transform('mean')

        # Calculate braking times and total laptime in seconds
        lap_tel['TotalTime'] = lap_tel['Time'].iloc[-1].total_seconds()

        brake_start_dict = {}
        brake_end_dict = {}
        brake_start_speed_dict = {}
        brake_end_speed_dict = {}
        for zone, group in lap_tel.groupby('BrakeZone'):
            brake_start_dict[zone] = group['Time'].min().total_seconds()
            brake_end_dict[zone] = group['Time'].max().total_seconds()
            brake_start_speed_dict[zone] = group['Speed'].max()
            brake_end_speed_dict[zone] = group['Speed'].min()
        
        # Map each new value 
        lap_tel['SpeedatBrakeStart'] = lap_tel['BrakeZone'].map(brake_start_speed_dict)
        lap_tel['SpeedatBrakeEnd'] = lap_tel['BrakeZone'].map(brake_end_speed_dict)
        lap_tel['BrakeStartTime'] = lap_tel['BrakeZone'].map(brake_start_dict)
        lap_tel['BrakeEndTime'] = lap_tel['BrakeZone'].map(brake_end_dict)
        lap_tel['TimeBraking'] = lap_tel['BrakeEndTime'] - lap_tel['BrakeStartTime']

        # Convert from kph to m/s
        lap_tel['SpeedatBrakeStartMS'] = lap_tel['SpeedatBrakeStart'] * .2778
        lap_tel['SpeedatBrakeEndMS'] = lap_tel['SpeedatBrakeEnd'] * .2778

        # Calculate Deceleration
        lap_tel['Deceleration'] = (0 - lap_tel['SpeedatBrakeStartMS']) / lap_tel['TimeBraking']

        # Calculate Theoretical Brake distance
        lap_tel['MinBrakeDistance'] = (lap_tel['SpeedatBrakeStartMS']**2) / (2 * (abs(lap_tel['Deceleration'])))

        # Calculate Braking Effiency
        lap_tel['BrakingEfficency'] = (lap_tel['MinBrakeDistance'] / lap_tel['TotalDistanceBraked']) * 100

        # Normalize Braking starting and Total Distance Braked into percentages of the total laptime
        lap_tel['BrakeStartTimeNor'] = lap_tel['BrakeStartTime'] / lap_tel['TotalTime']
        lap_tel['TotalDistanceBrakedNor'] = lap_tel['TotalDistanceBraked'] / lap_tel['Distance'].max()

        # append data to total telemetry. 
        total_tel = pd.concat([total_tel, lap_tel], ignore_index=True)

        # Calculate key variables
        brake_start_std = total_tel['BrakeStartTimeNor'].std()
        brake_distance_std = total_tel['TotalDistanceBrakedNor'].std()
        correlation_coe = total_tel[['BrakeStartTime', 'TotalDistanceBrakedNor']].corr()['TotalDistanceBrakedNor'].iloc[0]
        
        brake_consistency_score = (.4 * brake_start_std) + (.3 * brake_distance_std) + (.3 * correlation_coe)

        # remove all braking events that are false positives & outliers caused by mini brake events 
        total_tel = total_tel[total_tel['Deceleration'] > -800]

        # calculate driver confidence 
        driver_confidence = (.3 * (1 - brake_consistency_score)) + (.2 * abs(total_tel['Deceleration'].mean())) + (.4 * brake_consistency_score) - (.1 * total_tel['TotalDistanceBrakedNor'].mean())

    return total_tel, driver_confidence, brake_consistency_score


def get_statistical_metrics(lap):
    #Generate Lap list
    lap_list = lap['LapNumber'].to_list()
    lap_cols = lap.telemetry.columns
    total_tel = pd.DataFrame(columns=lap_cols)
    for lap in lap_list:
        lap_tel = lap[lap['LapNumber'] == lap].telemetry
        lap_tel['LapNumber'] = lap
        # Now Calculate other features such as Decleration
        lap_tel['DistanceBraked'] = lap_tel.groupby('BrakeZone')['Distance'].diff().fillna(0)
        lap_tel['TotalDistanceBraked'] = lap_tel.groupby('BrakeZone')['DistanceBraked'].transform('sum')
        # Now Calculate Average Speed at braking
        lap_tel['AvgSpeedBraking'] = lap_tel.groupby('BrakeZone')['Speed'].transform('mean')
        # Calculate braking times and total laptime in seconds
        lap_tel['TotalTime'] = lap_tel['Time'].iloc[-1].total_seconds()
        brake_start_dict = {}
        brake_end_dict = {}
        brake_start_speed_dict = {}
        brake_end_speed_dict = {}
        for zone, group in lap_tel.groupby('BrakeZone'):
            brake_start_dict[zone] = group['Time'].min().total_seconds()
            brake_end_dict[zone] = group['Time'].max().total_seconds()
            brake_start_speed_dict[zone] = group['Speed'].max()
            brake_end_speed_dict[zone] = group['Speed'].min()

        # Map each new value 
        lap_tel['SpeedatBrakeStart'] = lap_tel['BrakeZone'].map(brake_start_speed_dict)
        lap_tel['SpeedatBrakeEnd'] = lap_tel['BrakeZone'].map(brake_end_speed_dict)
        lap_tel['BrakeStartTime'] = lap_tel['BrakeZone'].map(brake_start_dict)
        lap_tel['BrakeEndTime'] = lap_tel['BrakeZone'].map(brake_end_dict)
        lap_tel['TimeBraking'] = lap_tel['BrakeEndTime'] - lap_tel['BrakeStartTime']

        # Convert from kph to m/s
        lap_tel['SpeedatBrakeStartMS'] = lap_tel['SpeedatBrakeStart'] * .2778
        lap_tel['SpeedatBrakeEndMS'] = lap_tel['SpeedatBrakeEnd'] * .2778

        # Calculate Deceleration
        lap_tel['Deceleration'] = (lap_tel['SpeedatBrakeStartMS']) / lap_tel['TimeBraking']
    return total_tel